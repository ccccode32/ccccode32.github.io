(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{510:function(t,a,s){t.exports=s.p+"assets/img/20210417.2b72c9c9.png"},556:function(t,a,s){"use strict";s.r(a);var e=s(22),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"diff-方法优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-方法优化"}},[t._v("#")]),t._v(" diff 方法优化")]),t._v(" "),e("p",[t._v("https://vue-next-template-explorer.netlify.app/")]),t._v(" "),e("ul",[e("li",[t._v("Vue2 中的虚拟 dom 是进行全量的对比")]),t._v(" "),e("li",[t._v("Vue3 中新增了静态标记（PatchFlag）,在与上次虚拟节点进行比较的时候，只比较带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的内容")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(510),alt:"20210417.png"}})]),t._v(" "),e("h2",{attrs:{id:"hoiststatic-静态提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hoiststatic-静态提升"}},[t._v("#")]),t._v(" hoistStatic 静态提升")]),t._v(" "),e("ul",[e("li",[t._v("Vue2 中无论元素是否参与更新，每次都会重新创建")]),t._v(" "),e("li",[t._v("Vue3 中对于不参与更新的元素，只会被创建一次，之后会在每次渲染的时候被不停的复用")])]),t._v(" "),e("h2",{attrs:{id:"cachehandlers-事件侦听器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cachehandlers-事件侦听器缓存"}},[t._v("#")]),t._v(" cacheHandlers 事件侦听器缓存")]),t._v(" "),e("ul",[e("li",[t._v("默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化，但是因为是同一个函数，所以没有跟踪变化，直接缓存起来复用即可")])]),t._v(" "),e("h2",{attrs:{id:"ssr渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssr渲染"}},[t._v("#")]),t._v(" ssr渲染")]),t._v(" "),e("ul",[e("li",[t._v("当有大量静态的内容时候，这些内容会被当做纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值嵌入进去，这样会比通过虚拟 dom 来渲染的快上很多很多")]),t._v(" "),e("li",[t._v("当静态内容大到一定量级时候，会用 _createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml, 就不需要创建对象，然后根据对象渲染。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);